const semver = require('semver');
const jwt = require('jsonwebtoken');
const JSONToCSV = require('json2csv');
const sequelize = require('#db/sequelize');
const sanitize = require('#server/controllers/userController/helpers/sanitize');
const checkPassword = require('#server/controllers/userController/helpers/checkPassword');
const validate = require('#server/controllers/userController/helpers/validate');
const userService = require('#server/services/userService');
const { triggerNewUserAlert } = require('#server/utils/mattermost');
const { mattermost } = require('#server/config');
const { toString: dateToString } = require('#server/utils/date');

const {
    generateAccessTokenFor, hashPassword, getPasswordResetLink,
    getExpiracyDateForActivationTokenCreatedAt,
} = require('#server/utils/auth');
const permissionsDescription = require('#server/permissions_description');
const accessRequestService = require('#server/services/accessRequest/accessRequestService');
const {
    sendUserNewPassword,
    sendAdminWelcome,
} = require('#server/mails/mails');

const { auth: authConfig } = require('#server/config');

module.exports = models => ({
    async list(req, res) {
        try {
            const users = await models.user.findAll(req.user);
            res.status(200).send(users);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la récupération des données en base',
                    developer_message: error.message,
                },
            });
        }
    },

    async listExport(req, res) {
        try {
            const users = await models.user.listExport();
            const csv = JSONToCSV.parse(users);

            // The frontend expect a JSON for every API calls, so we wrap the CSV in a json entry
            res.status(200).send({
                csv,
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la récupération des données en base',
                    developer_message: error.message,
                },
            });
        }
    },

    async get(req, res) {
        try {
            const user = await models.user.findOne(req.params.id, { extended: true }, req.user);
            res.status(200).send(user);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la récupération des données en base',
                    developer_message: error.message,
                },
            });
        }
    },

    async signin(req, res) {
        const { email, password } = req.body;

        if (typeof email !== 'string') {
            return res.status(400).send({
                success: false,
                error: {
                    user_message: 'Ces identifiants sont incorrects',
                    developer_message: 'The email address must be a string',
                    fields: {
                        email: ['L\'adresse e-mail est invalide'],
                    },
                },
            });
        }

        if (typeof password !== 'string') {
            return res.status(400).send({
                success: false,
                error: {
                    user_message: 'Ces identifiants sont incorrects',
                    developer_message: 'The password must be a string',
                    fields: {
                        password: ['Le mot de passe est invalide'],
                    },
                },
            });
        }

        const user = await models.user.findOneByEmail(email, {
            auth: true,
        });

        if (user === null) {
            return res.status(403).send({
                success: false,
                error: {
                    user_message: 'Ces identifiants sont incorrects',
                    developer_message: 'The given credentials do not match an existing user',
                },
            });
        }

        if (user.status !== 'active') {
            return res.status(400).send({
                success: false,
                error: {
                    user_message: 'Votre compte doit être activé avant utilisation',
                    developer_message: 'The user is not activated yet',
                },
            });
        }

        const hashedPassword = hashPassword(password, user.salt);
        if (hashedPassword !== user.password) {
            return res.status(403).send({
                success: false,
                error: {
                    user_message: 'Ces identifiants sont incorrects',
                    developer_message: 'The given credentials do not match an existing user',
                },
            });
        }

        return res.status(200).send({
            success: true,
            token: generateAccessTokenFor(user),
        });
    },

    renewToken(req, res) {
        const { id: userId, email } = req.user;

        return res.status(200).send({
            token: generateAccessTokenFor({ id: userId, email }),
        });
    },

    /**
     * Returns information about... yourself!
     */
    async me(req, res) {
        const user = await models.user.findOne(req.user.id, {
            extended: true,
        });
        return res.status(200).send(user);
    },

    /**
     * Updates some data about the current user
     */
    async edit(req, res, next) {
        const { id: paramId } = req.params;
        const { id: connectedUserId } = req.user;

        const userId = paramId || connectedUserId;

        const {
            first_name: firstName, last_name: lastName, email, phone, position,
            subscribed_to_summary: subscribedToSummary,
        } = req.body;
        const user = await models.user.findOne(userId, { auth: true });

        if (user === null) {
            res.status(500).send({
                error: {
                    user_message: 'Impossible de trouver vos informations en bases de données.',
                    developer_message: `User #${userId} does not exist`,
                },
            });
            return next(new Error(`User #${userId} does not exist`));
        }

        // actually update the user
        const data = {
            first_name: firstName,
            last_name: lastName,
            email,
            phone,
            position,
            subscribed_to_summary: subscribedToSummary,
        };

        if (req.body.password) {
            data.password = hashPassword(req.body.password, user.salt);
        }

        try {
            await models.user.update(userId, data);
            return res.status(200).send({
                id: user.userId,
                email: user.email,
                position,
                first_name: firstName,
                last_name: lastName,
                departement: user.departement,
                subscribed_to_summary: subscribedToSummary,
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue dans l\'écriture de vos informations en base de données.',
                    developer_message: error.message,
                },
            });
            return next(error);
        }
    },

    async create(req, res) {
        // create the user
        const result = await userService.create(
            {
                last_name: req.body.last_name,
                first_name: req.body.first_name,
                email: req.body.email,
                phone: req.body.phone || null,
                organization: req.body.organization_full ? req.body.organization_full.id : null,
                new_association: req.body.new_association === true,
                new_association_name: req.body.new_association_name || null,
                new_association_abbreviation: req.body.new_association_abbreviation || null,
                departement: req.body.departement || null,
                position: req.body.position,
                access_request_message: null,
            },
            req.user.id,
        );

        if (result.error) {
            return res.status(result.error.code).send(result.error.response);
        }

        return res.status(200).send(result);
    },

    /**
     * Updates comments about a user
     */
    async setAdminComments(req, res, next) {
        try {
            await models.user.update(req.params.id, {
                admin_comments: req.body.comment,
            });
            return res.status(200).send({
                admin_comments: req.body.comment,
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue dans l\'écriture de vos informations en base de données.',
                },
            });
            return next(error);
        }
    },

    async setDefaultExport(req, res, next) {
        const { export: exportValue } = req.body;

        if (exportValue === undefined) {
            return res.status(400).send({
                success: false,
                error: {
                    user_message: 'Les nouvelles préférences d\'export sont manquantes',
                    developer_message: 'The new default export value is missing',
                },
            });
        }

        try {
            await models.user.update(req.user.id, {
                defaultExport: exportValue,
            });
        } catch (error) {
            res.status(500).send({
                success: false,
                error: {
                    user_message: 'La sauvegarde de vos préférences a échoué',
                    developer_message: `Failed to store the new default-export into database: ${error.message}`,
                },
            });
            return next(error);
        }

        return res.status(200).send({
            success: true,
        });
    },

    async checkActivationToken(req, res) {
        if (!req.params.token) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation est manquant',
                    developer_message: 'The activation token is missing',
                },
            });
        }

        let decoded;
        try {
            decoded = jwt.verify(req.params.token, authConfig.secret);
        } catch (error) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation est invalide ou expiré.\nNous vous invitons à contacter l\'administrateur local qui vous a envoyé le mail avec ce lien d\'activation.',
                    developer_message: 'The activation token is either invalid or expired',
                },
            });
        }

        let user;
        if (decoded.userId !== undefined) {
            user = await models.user.findOne(decoded.userId);
        } else {
            user = await models.user.findOneByAccessId(decoded.id);
        }

        if (user === null) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation ne correspond à aucun utilisateur',
                    developer_message: 'The activation token does not match a real user',
                },
            });
        }

        if (user.status !== 'new') {
            return res.status(400).send({
                error: {
                    user_message: 'Ce compte utilisateur est déjà activé',
                    developer_message: 'The user is already activated',
                },
            });
        }

        return res.status(200).send({
            id: user.id,
            email: user.email,
        });
    },

    async checkPasswordToken(req, res) {
        if (!req.params.token) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification est manquant',
                    developer_message: 'The password token is missing',
                },
            });
        }

        let decoded;
        try {
            decoded = jwt.verify(req.params.token, authConfig.secret);
        } catch (error) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification est invalide ou expiré.\nNous vous invitons à reprendre le formulaire de demande de renouvelement de mot de passe.',
                    developer_message: 'The password token is either invalid or expired',
                },
            });
        }

        if (decoded.type !== 'password_reset') {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification est invalide',
                    developer_message: 'The given token is not a password token',
                },
            });
        }

        const user = await models.user.findOne(decoded.userId);
        if (user === null) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification ne correspond à aucun utilisateur',
                    developer_message: 'The password token does not match a real user',
                },
            });
        }

        return res.status(200).send({
            id: user.id,
            email: user.email,
        });
    },

    async sendActivationLink(req, res, next) {
        let user;
        try {
            user = await models.user.findOne(req.params.id, { extended: true }, req.user, 'activate');
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la lecture en base de données',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        if (user === null) {
            return res.status(404).send({
                error: {
                    user_message: 'L\'utilisateur auquel envoyer un accès n\'a pas été trouvé en base de données',
                    developer_message: null,
                },
            });
        }

        if (user.status !== 'new') {
            return res.status(400).send({
                error: {
                    user_message: 'L\'utilisateur concerné n\'a pas de demande d\'accès en attente',
                    developer_message: null,
                },
            });
        }

        try {
            await sequelize.transaction(async (transaction) => {
                const { options } = permissionsDescription[user.role_id];
                const requestedOptions = options
                    .filter(({ id }) => req.body.options && req.body.options[id] === true)
                    .map(({ id }) => id);
                await models.user.setPermissionOptions(user.id, requestedOptions, transaction);

                // reload the user to take options into account (they might have changed above)
                user = await models.user.findOne(
                    req.params.id,
                    { extended: true },
                    req.user,
                    'activate',
                    transaction,
                );

                const now = new Date();
                const expiresAt = getExpiracyDateForActivationTokenCreatedAt(now);
                const userAccessId = await models.userAccess.create({
                    fk_user: user.id,
                    sent_by: req.user.id,
                    created_at: now,
                    expires_at: expiresAt,
                }, transaction);

                await accessRequestService.resetRequestsForUser(user);
                await accessRequestService.handleAccessRequestApproved(
                    user,
                    {
                        id: userAccessId,
                        expires_at: expiresAt.getTime() / 1000,
                        sent_by: req.user,
                    },
                );
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'envoi du lien d\'activation',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async denyAccess(req, res, next) {
        let user;
        try {
            user = await models.user.findOne(req.params.id, undefined, req.user, 'activate');
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la lecture en base de données',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        if (user === null) {
            return res.status(404).send({
                error: {
                    user_message: 'L\'utilisateur auquel refuser l\'accès n\'a pas été trouvé en base de données',
                    developer_message: null,
                },
            });
        }

        if (user.status !== 'new') {
            return res.status(400).send({
                error: {
                    user_message: 'L\'utilisateur concerné n\'a pas de demande d\'accès en attente',
                    developer_message: null,
                },
            });
        }

        try {
            await accessRequestService.handleAccessRequestDenied(user, req.user);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'envoi du mail',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        try {
            await models.user.delete(req.params.id);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la suppression du compte de la base de données',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async activate(req, res, next) {
        if (!req.body.token) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation est manquant',
                    developer_message: 'The activation token is missing',
                },
            });
        }

        let decoded;
        try {
            decoded = jwt.verify(req.body.token, authConfig.secret);
        } catch (error) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation est invalide ou expiré',
                    developer_message: 'The activation token is either invalid or expired',
                },
            });
        }

        let user;
        if (decoded.userId !== undefined) {
            user = await models.user.findOne(decoded.userId, { auth: true });
        } else {
            user = await models.user.findOneByAccessId(decoded.id, { auth: true });
        }

        if (user === null) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation ne correspond à aucun utilisateur',
                    developer_message: 'The activation token does not match a real user',
                },
            });
        }

        if (user.id !== parseInt(req.params.id, 10)) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'activation n\'est pas valide',
                    developer_message: 'The activation token does not match the user id',
                },
            });
        }

        if (user.status === 'active') {
            return res.status(400).send({
                error: {
                    user_message: 'Ce compte utilisateur est déjà activé',
                    developer_message: 'The user is already activated',
                },
            });
        }

        const errors = checkPassword(req.body.password);
        if (errors.length > 0) {
            return res.status(400).send({
                error: {
                    user_message: 'Le mot de passe est invalide',
                    developer_message: 'Input data is invalid',
                    fields: {
                        password: errors,
                    },
                },
            });
        }

        try {
            await sequelize.transaction(async (transaction) => {
                const now = new Date();

                await models.organization.activate(user.organization.id, transaction);
                await models.user.update(user.id, {
                    password: hashPassword(req.body.password, user.salt),
                    fk_status: 'active',
                }, transaction);
                await models.userAccess.update(decoded.id, {
                    used_at: now,
                }, transaction);

                await accessRequestService.handleAccessActivated(user);
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'écriture en base de données',
                    developer_message: 'Failed updating the user',
                },
            });
            return next(error);
        }

        // Send a Matermost alert, if it fails, do nothing
        try {
            if (mattermost) {
                await triggerNewUserAlert(user);
            }
        } catch (err) {
            // eslint-disable-next-line no-console
            console.log(`Error with new user webhook : ${err.message}`);
        }

        return res.status(200).send({});
    },

    async setNewPassword(req, res, next) {
        if (!req.body.token) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification est manquant',
                    developer_message: 'The password token is missing',
                },
            });
        }

        let decoded;
        try {
            decoded = jwt.verify(req.body.token, authConfig.secret);
        } catch (error) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification est invalide ou expiré',
                    developer_message: 'The password token is either invalid or expired',
                },
            });
        }

        if (decoded.type !== 'password_reset') {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification n\'est pas valide',
                    developer_message: 'The password token does not match the user id',
                },
            });
        }

        const user = await models.user.findOne(decoded.userId, { auth: true });
        if (user === null) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification ne correspond à aucun utilisateur',
                    developer_message: 'The password token does not match a real user',
                },
            });
        }

        if (user.id !== parseInt(req.params.id, 10)) {
            return res.status(400).send({
                error: {
                    user_message: 'Le jeton d\'identification n\'est pas valide',
                    developer_message: 'The password token does not match the user id',
                },
            });
        }

        const errors = checkPassword(req.body.password);
        if (errors.length > 0) {
            return res.status(400).send({
                error: {
                    user_message: 'Le mot de passe est invalide',
                    developer_message: 'Input data is invalid',
                    fields: {
                        password: errors,
                    },
                },
            });
        }

        try {
            await models.user.update(user.id, {
                password: hashPassword(req.body.password, user.salt),
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'écriture en base de données',
                    developer_message: 'Failed updating the user',
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async upgrade(req, res, next) {
        // ensure the user exists and actually needs an upgrade
        let user;
        try {
            user = await models.user.findOne(req.params.id, { auth: true });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est surenue lors de la lecture de la base de données',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        if (user === null) {
            return res.status(404).send({
                error: {
                    user_message: 'Votre compte n\'a pas été retrouvé en base de données',
                },
            });
        }

        if (user.position !== '') {
            return res.status(400).send({
                error: {
                    user_message: 'Votre compte est déjà à jour',
                },
            });
        }

        // validate the input data
        const rawData = {
            position: req.body.position,
            phone: req.body.phone,
            password: req.body.password,
        };

        const fields = [
            { key: 'position', sanitizer: 'string' },
            { key: 'phone', sanitizer: 'string' },
            { key: 'password', sanitizer: 'string' },
        ];

        const sanitizedData = sanitize(rawData, fields);
        const errors = await validate(sanitizedData, fields);

        if (Object.keys(errors).length > 0) {
            return res.status(400).send({
                error: {
                    user_message: 'Certaines informations saisies sont incorrectes',
                    developer_message: 'Input data is invalid',
                    fields: errors,
                },
            });
        }

        try {
            await models.user.update(user.id, Object.assign({}, sanitizedData, {
                password: hashPassword(sanitizedData.password, user.salt),
            }));
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'écriture en base de données',
                    developer_message: error.message,
                },
            });
            next(error);
        }

        return res.status(200).send({});
    },

    async remove(req, res, next) {
        let user;
        try {
            user = await models.user.findOne(req.params.id, undefined, req.user, 'deactivate');
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la lecture en base de données',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        if (user === null) {
            return res.status(404).send({
                error: {
                    user_message: 'L\'utilisateur auquel supprimer l\'accès n\'a pas été trouvé en base de données',
                    developer_message: null,
                },
            });
        }

        try {
            await models.user.deactivate(req.params.id);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la mise à jour du compte',
                    developer_message: error.message,
                },
            });
            next(error);
        }

        return res.status(200).send({});
    },

    async updateLocalAdmin(req, res, next) {
        const { admin } = req.body;

        try {
            const user = await models.user.findOne(req.params.id);

            if (user && admin) {
                await models.user.upgradeLocalAdmin(req.params.id);
                await sendAdminWelcome(user);
            } else if (user) {
                await models.user.downgradeLocalAdmin(req.params.id);
            }
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la mise à jour du compte',
                    developer_message: error.message,
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async setRoleRegular(req, res, next) {
        try {
            await models.user.update(req.body.user.id, {
                fk_role_regular: req.body.role.id,
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la mise à jour du compte',
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async requestNewPassword(req, res, next) {
        const data = { email: req.body.email };
        const fields = [
            { key: 'email', sanitizer: 'string', validatorOptions: [false] },
        ];
        const sanitizedData = sanitize(data, fields);

        const errors = await validate(sanitizedData, fields);
        if (Object.keys(errors).length > 0) {
            return res.status(400).send({
                error: {
                    user_message: 'Certaines données sont manquantes ou invalides',
                    fields: errors,
                },
            });
        }

        let user;
        try {
            user = await models.user.findOneByEmail(sanitizedData.email);
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de la lecture en base de données',
                    developer_messaage: error.message,
                },
            });
            return next(error);
        }

        if (user !== null) {
            try {
                const resetLink = getPasswordResetLink(user);
                await sendUserNewPassword(user, {
                    variables: {
                        link: {
                            link: resetLink.link,
                            expiracyDate: dateToString(resetLink.expiracyDate, true),

                        },
                    },
                });
            } catch (error) {
                res.status(500).send({
                    error: {
                        user_message: 'Une erreur est survenue lors de l\'envoi du mail',
                        developer_message: error.message,
                    },
                });
                return next(error);
            }
        }

        return res.status(200).send({});
    },

    async setLastChangelog(req, res, next) {
        const changelog = semver.valid(req.body.version);
        if (changelog === null) {
            return res.status(400).send({
                error: {
                    user_message: 'Le numéro de version passé en paramètre est invalide',
                },
            });
        }

        if (req.user.last_changelog !== null && semver.gte(req.user.last_changelog, changelog)) {
            return res.status(200).send({});
        }

        try {
            await models.user.update(req.user.id, {
                last_changelog: changelog,
            });
        } catch (error) {
            res.status(500).send({
                error: {
                    user_message: 'Une erreur est survenue lors de l\'écriture en base de données',
                },
            });
            return next(error);
        }

        return res.status(200).send({});
    },

    async acceptCharte(req, res, next) {
        if (parseInt(req.params.id, 10) !== req.user.id) {
            return res.status(400).send({
                user_message: 'Vous ne pouvez pas accepter la charte pour un autre utilisateur que vous-même',
            });
        }

        const charte = await models.charteEngagement.getLatest();
        if (charte === null) {
            return res.status(400).send({
                user_message: 'Il n\'y a aucune charte à accepter pour le moment',
            });
        }

        if (req.body.version_de_charte !== charte.version) {
            return res.status(400).send({
                user_message: 'Une charte plus récente existe, vous devez accepter la charte la plus récente',
            });
        }

        if (req.user.charte_engagement_a_jour !== true) {
            try {
                await models.user.update(req.user.id, {
                    charte_engagement_signee: req.body.version_de_charte,
                });
            } catch (error) {
                res.status(500).send({
                    user_message: 'Une erreur est survenue lors de la mise à jour de la base de données',
                    developer_message: error.message,
                });
                return next(error);
            }
        }

        if (req.body.charte_agreement !== true) {
            return res.status(400).send({
                user_message: 'Vous devez vous engager à respecter les conditions d\'utilisation de la plateforme',
            });
        }

        if (req.body.confidentiality_agreement !== true) {
            return res.status(400).send({
                user_message: 'Vous devez vous engager à ne pas diffuser les données de la plateforme',
            });
        }

        return res.status(200).send({});
    },
});
